# Применение свёрточного фильтра к изображению кота в градациях серого

python
Копировать код
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
Используемые библиотеки
NumPy: Для эффективных математических операций, особенно матричных, необходимых для выполнения свёртки.
Matplotlib: Для отображения оригинального и обработанного изображения.
PIL (Python Imaging Library): Для загрузки и преобразования изображения в градации серого.

## Функция свёртки conv2d
Функция conv2d выполняет свёртку изображения с заданным ядром (или фильтром). Это помогает выявить ключевые особенности изображения, такие как края и контуры.

python
Копировать код
def conv2d(image, kernel):
    img_height, img_width = image.shape
    kernel_size = kernel.shape[0]
Параметры
image: Изображение в градациях серого, представленное как 2D массив NumPy.
kernel: Ядро свёртки — небольшой матричный фильтр, который используется для обработки изображения. В этом примере используется фильтр 3x3 для детектирования краёв.
Процесс
img_height и img_width: Определяют высоту и ширину изображения.
kernel_size: Определяет размер ядра. Мы предполагаем, что ядро квадратное, поэтому используем kernel.shape[0].


## Вычисление размеров выходного изображения
Мы уменьшаем размер изображения на величину ядра - 1, так как свёртка проводится только на центральной части изображения, чтобы избежать выхода за границы.

python
Копировать код
    output_height = img_height - kernel_size + 1
    output_width = img_width - kernel_size + 1
    output = np.zeros((output_height, output_width))
Объяснение
output_height и output_width: Это размеры выходного изображения после применения свёртки.
output: Создаём пустую матрицу (2D массив) размером output_height x output_width для хранения результатов.


## Выполнение свёртки
В этом цикле функция перемещает ядро по всему изображению и вычисляет значения для каждой позиции ядра.

python
Копировать код
    for i in range(output_height):
        for j in range(output_width):
            output[i, j] = np.sum(image[i:i+kernel_size, j:j+kernel_size] * kernel)
Пошагово
Циклы for: Перебираем каждый пиксель изображения, где ядро полностью помещается.
image[i
+kernel_size, j
+kernel_size]: Извлекаем область изображения, которая соответствует размеру ядра.
np.sum(... * kernel): Умножаем каждый элемент выделенной области на соответствующий элемент ядра, затем складываем все значения, чтобы получить одно итоговое значение.
output[i, j]: Записываем результат в выходное изображение.


## Загрузка изображения и преобразование в градации серого
python
Копировать код
img_path = '/content/drive/MyDrive/Univer/cat.jpeg'
img = Image.open(img_path).convert('L')
img = np.array(img)
Объяснение
Image.open(img_path): Загружает изображение.
convert('L'): Преобразует изображение в градации серого (модель 'L' означает "luminance" — яркость).
np.array(img): Преобразует изображение в массив NumPy, что упрощает выполнение математических операций.


## Определение ядра свёртки (фильтра)
python
Копировать код
kernel = np.array([[-1, -1, -1],
                   [-1,  8, -1],
                   [-1, -1, -1]])

                   
### Описание ядра
Этот фильтр используется для выделения краёв. Значение в центре ядра положительное и имеет большую величину, тогда как остальные значения отрицательные. Это усиливает контраст между центральным пикселем и его соседями, подчеркивая границы.

## Применение свёртки к изображению
python
Копировать код
conv_result = conv2d(img, kernel)
Применяем функцию conv2d с заданным ядром для получения изображения с выделенными краями.


## Усиление контраста выходного изображения
Чтобы результат был более выразительным, нормализуем значения и усиливаем контраст:

python
Копировать код
conv_result = (conv_result - np.min(conv_result)) / (np.max(conv_result) - np.min(conv_result)) * 255
conv_result = np.clip(conv_result * 2, 0, 255)
conv_result = conv_result.astype(np.uint8)
Объяснение
Нормализация: Преобразуем значения в диапазон от 0 до 255.
Усиление контраста: Умножаем значения на 2, чтобы сделать края более заметными.
astype(np.uint8): Преобразуем значения в целые числа от 0 до 255 для совместимости с изображениями.


## Визуализация результата
python
Копировать код
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.imshow(img, cmap='gray')
plt.title('Оригинальное изображение')

plt.subplot(1, 2, 2)
plt.imshow(conv_result, cmap='gray')
plt.title('Результат свертки с повышенным контрастом')

plt.show()
Описание
plt.figure(figsize=(10, 5)): Устанавливаем размер области для двух изображений.
plt.subplot(1, 2, 1): Первый subplot для оригинального изображения.
plt.imshow(img, cmap='gray'): Отображаем оригинальное изображение в градациях серого.
plt.subplot(1, 2, 2): Второй subplot для обработанного изображения.
plt.imshow(conv_result, cmap='gray'): Отображаем результат свёртки в градациях серого.
plt.show(): Показываем оба изображения на экране.
