# Применение свёрточного фильтра к изображению кота с помощью TensorFlow
TensorFlow: Основная библиотека для машинного обучения и обработки изображений. Здесь используется для выполнения свёртки.

## Загрузка изображения
```python
img_path = '/content/drive/MyDrive/Univer/cat.jpeg'
img = image.load_img(img_path, target_size=(224, 224))
```

- img_path: Путь к изображению на Google Диске.
- image.load_img: Загружает изображение и преобразует его в формат, понятный Keras.
- target_size=(224, 224): Изменяет размер изображения на 224×224 пикселя для унификации и уменьшения вычислительной нагрузки.

  
## Преобразование изображения в массив чисел
```python
img_array = image.img_to_array(img) / 255.0
image.img_to_array(img): Преобразует загруженное изображение в массив чисел, где каждый пиксель представлен тремя значениями (R, G и B).
/ 255.0: Нормализует значения в диапазон от 0 до 1, что упрощает обработку и улучшает стабильность свёрточной операции.
```

## Добавление размерности для батча
```python
img_array = np.expand_dims(img_array, axis=0)
```

Нейронные сети TensorFlow ожидают, что входное изображение будет иметь размерность (batch_size, height, width, channels). Здесь:

- expand_dims(..., axis=0): Добавляет новую размерность в начале массива, превращая его в форму (1, 224, 224, 3) (где 1 — размер батча).
 
## Подготовка ядра для применения к цветному изображению
```python
kernel = np.expand_dims(kernel, axis=-1)
kernel = np.repeat(kernel, 3, axis=-1)
kernel = np.expand_dims(kernel, axis=-1)
kernel = np.repeat(kernel, 3, axis=-1)
```
Изображение имеет три канала (RGB), поэтому фильтр нужно преобразовать для работы с цветным изображением. Пошагово:

- expand_dims(kernel, axis=-1): Добавляет одно измерение, превращая ядро в форму 3×3×1.
- np.repeat(kernel, 3, axis=-1): Повторяет ядро по последней оси 3 раза, получая ядро 3×3×3. Теперь оно охватывает все три канала (RGB).
- expand_dims(kernel, axis=-1): Добавляет ещё одно измерение для совместимости с форматом свёрточного слоя, превращая ядро в 3×3×3×1.
- np.repeat(kernel, 3, axis=-1): Повторяет ещё раз для создания ядра в форме 3×3×3×3, чтобы каждый канал обрабатывался независимо.

Теперь это ядро можно применять к каждому каналу изображения.

## Применение свёртки к изображению
```python
conv_layer = tf.nn.conv2d(img_array, kernel, strides=[1, 1, 1, 1], padding='SAME')
```

- tf.nn.conv2d: Выполняет операцию свёртки.
- img_array: Входное изображение.
- kernel: Ядро свёртки.
- strides=[1, 1, 1, 1]: Определяет шаг свёртки. 1,1 означает, что свёртка будет применяться ко всем пикселям. [1, h_stride, w_stride, 1] — это формат, где 1 для начала и конца остаётся фиксированным.
- padding='SAME': Сохраняет исходные размеры изображения, добавляя нули по краям, чтобы выходное изображение было того же размера, что и входное (224x224).


## Подготовка результата для визуализации
```python
conv_img = np.squeeze(conv_layer)
conv_img = np.clip(conv_img, 0, 1)
```

- np.squeeze: Удаляет измерение размера батча, чтобы преобразовать изображение из 224,224,3, что делает его подходящим для визуализации.
np.clip(conv_img, 0, 1): Ограничивает значения от 0 до 1, так как при свёртке могут появляться значения вне этого диапазона.


## Визуализация исходного и обработанного изображений
```python
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.imshow(img_array[0])  # Отображаем нормализованное изображение
plt.title('Оригинальное изображение')

plt.subplot(1, 2, 2)
plt.imshow(conv_img)
plt.title('Изображение после свертки')

plt.show()
```

- plt.figure(figsize=(10, 5)): Создаёт фигуру для отображения изображений.
- plt.subplot(1, 2, 1): Разделяет фигуру на два поля (1 строка, 2 столбца) и активирует первое поле для отображения оригинального изображения.
- plt.imshow(img_array[0]): Отображает оригинальное изображение. Здесь img_array[0] — это нормализованное изображение в формате 224x224 с 3 каналами.
- plt.subplot(1, 2, 2): Активирует второе поле для отображения изображения после свёртки.
- plt.imshow(conv_img): Отображает изображение после свёртки. conv_img — это выходное изображение, где края выделены с помощью ядра.
- plt.show(): Показывает оба изображения (исходное и после свёртки) в одной фигуре.
